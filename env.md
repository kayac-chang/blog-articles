# 關於 運行環境 跟 環境變數 與 .env

雖然有經驗的工程師可能覺得這個太簡單了，不太想花時間討論，
但確實感受到新進人員跟非技術人員不太理解而導致踩雷，
本文比較像是概論，
透過 他的思維出發點 再到 稍微一點點的技術細節 進行撰寫，
但如果要找更特定的細節像是 _CRA 的環境變數怎麼配置？_，
就不是這篇文章要探討的。

## 什麼是 _運行環境_ ？為什麼需要 _運行環境_ ？

因為基於一個單純的出發點，_風險管理_。

發布新的功能是伴隨著巨大風險的，因為我們可能會犯錯。
程式在未經過功能驗證跟品質管理的保護下發布給客戶，
客戶就會直接被程式錯誤所衝擊，
這就會影響到客戶對於公司或是產品的信賴，
而信用的損害即是公司營運的損害。

所以，工廠流水線在生產時，
一定會配備品保跟品管人員，
以保證產品能夠滿足需求，
而*軟體*也是同理。

但是不同於工廠的是，
軟體的開發跟迭代速度是快到無法想像的，
我們不可能為了要更新和測試新的功能，
而不斷地去暫停正在運行的服務，
因為暫停服務幾乎等同於是流失營收，
尤其是人流大的服務那個損失是即為巨大的。

為了不想要將正在運行的服務中斷，
但又可以讓我們順利的做測試，
所以我們會部署至少兩份以上**同樣的**運行環境，
一份用於正式運行環境，直接面向客戶，
而其餘份則是用於內部開發，面向開發或是測試人員。

## 運行環境的種類

- 正式區的運行環境，普遍稱為 **production**，**prod**，
- 而準備進正式區的環境，我們稱為 **staging**，**stg**，
- 根據團隊或是內部流程的不同，可能會準備更多環境，
  但不論是怎麼樣的規模，至少都會準備這兩個環境。

## 為什麼需要 _環境變數_ ？

為了前面拆分環境的需要，
我們的程式變成必須具備應映不同環境能調整部分參數的能力。

> 但我們希望程式能夠自己根據不同的運行環境主動調整部分參數，
> 而不需要手動更改其內部的程式碼。

### 舉個例子：

假設自家 API 的 production 運行網址為：`https://example.com`，
而 staging 為 `https://stg.example.com`。

如果我們是將 API 網址直接寫死在程式碼中，
變成我們需要準備兩份版本來應對兩個環境。

兩個環境可能還可以負荷，但假設是三份，四份以上，
那就變成我們要額外維護對應數量的版本，這並不有趣。

### _環境變數_ 來拯救

如果我們的程式碼能透過讀取環境變數，來改變 API 位置的話，
那不管多少份環境，我們的程式碼都不需要做任何改變，
因為他是直接跟據運行的環境下去調整的。

這解決了我們剛才提到的問題，
但卻延伸了另一個問題，
我們變成需要手動去各個環境配置環境變數。

假設只有一兩個環境倒好解決，
但近代開發逐漸走向雲端運算，
常常會搭配 Docker 用於封裝部署，
而 Docker 每次都是獨立且嶄新的環境。

我們並不想每次創建一個新的環境，
都要手動配置環境變數，這一樣很擾民。

所以我們需要一些配置檔，用於每次創建環境時，
自動將配置檔中的參數寫進環境變數，
而這就是截下來要談的。

## .env

基本上並沒有強制規定配置檔必須要什麼檔案格式或是名稱，
但隨著軟體開發社群的討論跟發展下，
普遍我們會有一些共識來輔助我們合作，
而 `.env` 也是其中一項。

有些程式語言會用其他的檔案格式像是：`json`，`yaml` ...etc，
但總體來說，要達到的目的是一樣的。

`.env` 格式非常單純，`KEY=VALUE` 即為鍵值對應的組合而已。
這個檔案被廣泛應用在前後端，包含 `webpack`，`node`，`vite`，`fast-api` ...

基本上使用邏輯就是：
在程式運行前，先將 `.env` 內的配置寫入運行環境變數，再跑程式。

這邊要強調前端打包稍微不同：
在打包前，先將 `.env` 內的配置靜態寫入(a.k.a 寫入純字串或數值)進編譯後的程式碼。

## 普遍命名原則

根據 [dotenv-flow](https://github.com/kerimdzhanov/dotenv-flow) 的命名原則，
我們會根據環境來改變要採用的 `.env` 配置。

公式：`.env.${NODE_ENV}[.local]`
白話來說，

- .env.production：正式區用的 `.env`
- .env.development：開發用的 `.env`
- .env.development.local：本地端才用的 `.env`
  ... 以此類推
